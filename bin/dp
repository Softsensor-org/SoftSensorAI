#!/usr/bin/env bash
# DevPilot meta-CLI: beautiful defaults for init, tickets, and review.
set -euo pipefail
ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
SHIM="$ROOT/tools/ai_shim.sh"
ART="$ROOT/artifacts"
mkdir -p "$ART"

say() { printf "%s\n" "$*"; }
have(){ command -v "$1" >/dev/null 2>&1; }

pick_cli() {
  # Prefer anthropic, then codex, gemini, grok
  for p in anthropic codex gemini grok; do
    if have "$p"; then echo "$p"; return; fi
  done
  echo ""
}

cmd_init() {
  say "â–¸ Running doctor â€¦"
  if [[ -x "$ROOT/scripts/doctor.sh" ]]; then "$ROOT/scripts/doctor.sh" || true; fi

  # Check for project file
  local project_file=""
  for pf in devpilot.project.yml devpilot.project.yaml .devpilot.yml .devpilot.yaml; do
    if [[ -f "$pf" ]]; then
      project_file="$pf"
      say "â–¸ Found project profile: $pf"
      break
    fi
  done

  if [[ -n "$project_file" ]]; then
    say "â–¸ Applying profile from $project_file â€¦"
    if [[ -x "$ROOT/scripts/apply_profile.sh" ]]; then "$ROOT/scripts/apply_profile.sh" || true; fi
  else
    say "â–¸ No project file found. Using defaults (skill=l1, phase=mvp) â€¦"
    say "  ğŸ’¡ Tip: Create devpilot.project.yml for zero-friction setup"
    if [[ -x "$ROOT/scripts/apply_profile.sh" ]]; then "$ROOT/scripts/apply_profile.sh" --skill l1 --phase mvp || true; fi
  fi

  say "â–¸ Building system/active.md â€¦"
  if [[ -x "$ROOT/scripts/system_build.sh" ]]; then "$ROOT/scripts/system_build.sh" || true; fi
  say "â–¸ Quick repo review â€¦"
  if grep -q '^repo-review:' "$ROOT/Justfile" 2>/dev/null; then just repo-review || true; fi

  # Pretty summary block
  say ""
  say "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  say "  INITIALIZATION COMPLETE"
  say "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  say ""
  say "  Project Setup"
  say "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  if [[ -n "$project_file" ]]; then
    say "  âœ“ Profile loaded from $project_file"
  else
    say "  âœ“ Default profile applied (skill=l1, phase=mvp)"
  fi
  say "  âœ“ System prompt built"
  say "  âœ“ Repository analyzed"
  say ""
  say "  Next Steps"
  say "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  say "  1. dp tickets    â†’ Generate structured backlog"
  say "  2. dp review     â†’ Review your changes with AI"
  say "  3. just dev      â†’ Start development server"
  say "  4. dp palette    â†’ Browse all commands"
  say ""
  say "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  say ""
}

build_tickets_prompt() {
  local out="$ART/tickets_prompt.txt"
  if [[ -f "$ROOT/.claude/commands/tickets-from-code.md" ]]; then
    cat "$ROOT/.claude/commands/tickets-from-code.md" > "$out"
  else
    cat > "$out" <<'EOF'
ROLE: Senior engineer. Produce a prioritized backlog as strict JSON (see schema in docs).
SCOPE: entire repo; include security, tests, docs, observability.
OUTPUT: JSON only (no markdown), then I will convert to CSV.
EOF
  fi
  echo "$out"
}

extract_json() {
  # Pull JSON object from noisy model output
  awk 'BEGIN{in=0} /^[[:space:]]*{/ && !in {in=1} in{print}' | \
  awk 'BEGIN{c=0} {print; for(i=1;i<=length($0);i++){ch=substr($0,i,1); if(ch=="{")c++; else if(ch=="}")c--;}} END{exit c!=0}'
}

cmd_tickets() {
  local sys="$ROOT/system/active.md"
  [[ -f "$sys" ]] || { say "error: $sys not found. Run dp init."; exit 1; }
  local prompt; prompt="$(build_tickets_prompt)"
  local raw="$ART/tickets_raw.txt" json="$ART/tickets.json" csv="$ART/tickets.csv"
  : > "$raw"

  say "â–¸ Generating tickets (CLI fallback: codexâ†’claudeâ†’geminiâ†’grok) â€¦"
  # Try providers via shim; neutral if none exist
  "$SHIM" --provider codex  --model "${AI_MODEL_CODEX:-codex-latest}"             --prompt-file "$prompt" > "$raw" 2> "$ART/tickets_codex.err"  || true
  [[ -s "$raw" ]] || "$SHIM" --provider claude --model "${AI_MODEL_CLAUDE:-claude-3-7-sonnet-20250219}" --prompt-file "$prompt" > "$raw" 2> "$ART/tickets_claude.err" || true
  [[ -s "$raw" ]] || "$SHIM" --provider gemini --model "${AI_MODEL_GEMINI:-gemini-1.5-pro-latest}"     --prompt-file "$prompt" > "$raw" 2> "$ART/tickets_gemini.err" || true
  [[ -s "$raw" ]] || "$SHIM" --provider grok   --model "${AI_MODEL_GROK:-grok-2-latest}"               --prompt-file "$prompt" > "$raw" 2> "$ART/tickets_grok.err"   || true

  if [[ ! -s "$raw" ]]; then
    say "â„¹ï¸  No AI CLI produced output. Install anthropic/codex/gemini/grok CLIs or run in CI with those CLIs."
    exit 0
  fi
  if extract_json < "$raw" > "$json"; then
    jq -r '
      .tickets[]
      | [
          .id, .title, .type, .priority, .effort,
          (.labels // [] | join("|")), (.assignee // ""),
          (.dependencies // [] | join("|")),
          (.notes // "" | gsub("[\r\n]+";" ")),
          (.acceptance_criteria // [] | join("; "))
        ] | @csv
    ' "$json" > "$csv" || true
    say "âœ… Wrote:"
    say "   - $json"
    [[ -s "$csv" ]] && say "   - $csv"
  else
    say "âš ï¸  Could not find valid JSON in model output. Try a smaller scope or a different CLI."
    exit 0
  fi
}

cmd_review() {
  local sys="$ROOT/system/active.md"
  [[ -f "$sys" ]] || { say "error: $sys not found. Run dp init."; exit 1; }
  local base="${BASE_BRANCH:-main}"
  local with_preview="${1:-}"

  # Check for preview flag
  if [[ "$with_preview" == "--preview" ]]; then
    say "â–¸ Review will include preview logs"
  fi

  git fetch --no-tags origin "$base" --depth=1 || true
  git diff --unified=1 --minimal --no-color "origin/$base"...HEAD > "$ART/review_diff.patch" || true
  local lines; lines=$(wc -l < "$ART/review_diff.patch" || echo 0)
  if [[ "$lines" -gt 6000 ]]; then head -n 6000 "$ART/review_diff.patch" > "$ART/review_diff.patch.head" && mv "$ART/review_diff.patch.head" "$ART/review_diff.patch"; fi

  # Analyze risk if tool exists
  local risk_tags=""
  local risk_prelude=""
  if [[ -x "$ROOT/tools/diff_risk.sh" ]]; then
    risk_tags=$("$ROOT/tools/diff_risk.sh" "$ART/review_diff.patch" tags 2>/dev/null || echo "")
    if [[ -n "$risk_tags" ]]; then
      say "â–¸ Risk analysis: $risk_tags"

      # Build risk-aware prelude
      risk_prelude="RISK: "
      if [[ "$risk_tags" =~ "level:critical" ]]; then
        risk_prelude+="â›” CRITICAL changes detected. "
      elif [[ "$risk_tags" =~ "level:high" ]]; then
        risk_prelude+="ğŸ”´ HIGH risk changes. "
      fi

      # Add specific risk focus
      [[ "$risk_tags" =~ "risk:auth" ]] && risk_prelude+="Auth flows modified - check for bypasses. "
      [[ "$risk_tags" =~ "risk:db" ]] && risk_prelude+="Database changes - verify migrations and queries. "
      [[ "$risk_tags" =~ "risk:payment" ]] && risk_prelude+="Payment code - audit thoroughly. "
      [[ "$risk_tags" =~ "risk:security" ]] && risk_prelude+="Security-sensitive - check for vulnerabilities. "
      [[ "$risk_tags" =~ "risk:api" ]] && risk_prelude+="API changes - verify backwards compatibility. "

      risk_prelude+="\n"
    fi
  fi

  # Collect preview logs if requested
  local preview_context=""
  if [[ "$with_preview" == "--preview" ]]; then
    say "â–¸ Collecting preview logs..."
    if [[ -x "$ROOT/tools/preview_logs.sh" ]]; then
      preview_context=$("$ROOT/tools/preview_logs.sh" 200 context 2>/dev/null || echo "")
    elif docker ps -q -f "name=preview-" > /dev/null 2>&1; then
      preview_context=$(docker logs preview-app-local --tail=200 2>&1 | grep -E "(ERROR|WARN|Exception)" | tail -50 || echo "")
    fi

    if [[ -n "$preview_context" ]]; then
      say "â–¸ Found preview context (errors/warnings will be included)"
    fi
  fi

  {
    [[ -n "$risk_prelude" ]] && echo -e "$risk_prelude"
    echo "ROLE: Senior code reviewer. Produce concise, file-scoped bullets with suggested changes."
    if [[ -n "$preview_context" ]]; then
      echo "CONTEXT: Preview environment is running. Review logs for runtime issues."
      echo ""
      echo "=== PREVIEW LOGS ==="
      echo "$preview_context" | head -50
      echo "=== END LOGS ==="
      echo ""
    fi
    echo "HINT: If diff seems truncated, outline issues file-by-file; ask for a follow-up on specific files as needed."
    echo "DIFF:"; cat "$ART/review_diff.patch"
  } > "$ART/review_prompt.txt"

  "$SHIM" --provider claude --model "${AI_MODEL_CLAUDE:-claude-3-7-sonnet-20250219}" --prompt-file "$ART/review_prompt.txt" > "$ART/review_local.txt" 2> "$ART/review_claude.err" || true
  [[ -s "$ART/review_local.txt" ]] || "$SHIM" --provider codex  --model "${AI_MODEL_CODEX:-codex-latest}"             --prompt-file "$ART/review_prompt.txt" > "$ART/review_local.txt" 2> "$ART/review_codex.err"  || true
  [[ -s "$ART/review_local.txt" ]] || "$SHIM" --provider gemini --model "${AI_MODEL_GEMINI:-gemini-1.5-pro-latest}"     --prompt-file "$ART/review_prompt.txt" > "$ART/review_local.txt" 2> "$ART/review_gemini.err" || true
  [[ -s "$ART/review_local.txt" ]] || "$SHIM" --provider grok   --model "${AI_MODEL_GROK:-grok-2-latest}"               --prompt-file "$ART/review_prompt.txt" > "$ART/review_local.txt" 2> "$ART/review_grok.err"   || true

  if [[ -s "$ART/review_local.txt" ]]; then
    say "âœ… Wrote: $ART/review_local.txt"
  else
    say "â„¹ï¸  No AI CLI produced output. Install an AI CLI to use dp review."
  fi
}

cmd_project() {
  # Create or show project file
  if [[ -f devpilot.project.yml ]]; then
    say "âœ“ Project file exists: devpilot.project.yml"
    say ""
    say "Current settings:"
    grep -E "^  (skill|phase|primary):" devpilot.project.yml | head -5
  else
    say "Creating devpilot.project.yml with sensible defaults..."

    # Detect current project name
    local project_name=$(basename "$PWD")

    # Create from template
    if [[ -f "$ROOT/templates/devpilot.project.yml" ]]; then
      sed "s/\${PROJECT_NAME:-MyProject}/$project_name/g" \
        "$ROOT/templates/devpilot.project.yml" > devpilot.project.yml
      say "âœ… Created devpilot.project.yml"
      say ""
      say "Next steps:"
      say "  1) Edit devpilot.project.yml to customize"
      say "  2) Run: dp init"
      say ""
      say "Key settings to review:"
      grep -E "^  (skill|phase|primary):" devpilot.project.yml | head -5
    else
      # Minimal fallback
      cat > devpilot.project.yml <<EOF
# DevPilot Project Profile
project:
  name: $project_name

profile:
  skill: l2          # l1=beginner, l2=intermediate, l3=expert
  phase: mvp         # poc, mvp, beta, scale
  teach_mode: false

personas:
  primary: pragmatic-coder

ci:
  gates:
    lint: required
    tests: required
    coverage: advisory
EOF
      say "âœ… Created minimal devpilot.project.yml"
    fi
  fi
}

cmd_palette() {
  # Interactive command palette with fzf
  local query="${1:-}"

  # Check for fzf
  if ! have fzf; then
    say "âš ï¸  fzf not found. Install with:"
    say "  brew install fzf    # macOS"
    say "  apt install fzf     # Ubuntu/Debian"
    say ""
    say "Or use: just commands  # to view command list"
    exit 1
  fi

  # Generate command registry if needed
  local registry="$ART/commands.json"
  if [[ ! -f "$registry" ]] || [[ "$ROOT/scripts/generate_command_registry.sh" -nt "$registry" ]]; then
    say "â–¸ Generating command registry..."
    if [[ -x "$ROOT/scripts/generate_command_registry.sh" ]]; then
      "$ROOT/scripts/generate_command_registry.sh" "$ART/commands.md" "$registry" >/dev/null 2>&1
    fi
  fi

  # Build command list for fzf
  local commands_file="$ART/palette_commands.txt"
  if [[ -f "$registry" ]]; then
    jq -r '.commands[] | "\(.command) :: \(.description) [\(.category)]"' "$registry" > "$commands_file"
  else
    # Fallback to basic commands
    cat > "$commands_file" <<'EOF'
dp init :: Initialize project
dp tickets :: Generate backlog
dp review :: Review code changes
dp palette :: Command palette
just dev :: Start dev server
just test :: Run tests
just lint :: Run linters
just fmt :: Format code
EOF
  fi

  # Interactive selection with fzf
  local selected
  if [[ -n "$query" ]]; then
    selected=$(cat "$commands_file" | fzf --query="$query" --select-1 --exit-0 \
      --prompt="DevPilot â–¸ " \
      --header="Select command (ESC to cancel)" \
      --preview-window=hidden \
      --height=40% \
      --layout=reverse \
      --border=rounded)
  else
    selected=$(cat "$commands_file" | fzf \
      --prompt="DevPilot â–¸ " \
      --header="Select command (ESC to cancel)" \
      --preview-window=hidden \
      --height=40% \
      --layout=reverse \
      --border=rounded)
  fi

  if [[ -n "$selected" ]]; then
    # Extract command from selection
    local cmd="${selected%% ::*}"
    say "â–¸ Running: $cmd"
    say ""

    # Execute the command
    eval "$cmd"
  fi
}

cmd_setup() {
  # Smart setup: detects whether to clone or use existing repo
  local url="${1:-}"

  say "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  say "  DEVPILOT SETUP"
  say "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  say ""

  # Check if we're in a git repo
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    say "âœ“ Detected existing repository: $(basename "$PWD")"
    say ""
    say "â–¸ Analyzing repository..."

    # Detect project type
    local project_type=""
    [[ -f package.json ]] && project_type="${project_type}Node.js "
    [[ -f requirements.txt || -f pyproject.toml ]] && project_type="${project_type}Python "
    [[ -f go.mod ]] && project_type="${project_type}Go "
    [[ -f Cargo.toml ]] && project_type="${project_type}Rust "

    [[ -n "$project_type" ]] && say "  Project type: $project_type"

    # Check for existing DevPilot files
    local existing_files=""
    [[ -f CLAUDE.md ]] && existing_files="${existing_files}CLAUDE.md "
    [[ -f devpilot.project.yml ]] && existing_files="${existing_files}devpilot.project.yml "
    [[ -d .claude ]] && existing_files="${existing_files}.claude/ "

    if [[ -n "$existing_files" ]]; then
      say "  Existing DevPilot files: $existing_files"
      say ""
      say "â–¸ Running setup with merge strategy..."
      "$ROOT/setup/existing_repo_setup.sh"
    else
      say ""
      say "â–¸ Adding DevPilot configuration..."
      "$ROOT/setup/existing_repo_setup.sh"
    fi
  elif [[ -n "$url" ]]; then
    # URL provided, clone and setup
    say "â–¸ Setting up new repository from: $url"
    say ""
    "$ROOT/setup/repo_wizard.sh" --url "$url"
  else
    # No repo, no URL - interactive mode
    say "No repository detected. Choose an option:"
    say ""
    say "  1) Setup current directory as new project"
    say "  2) Clone a repository and setup"
    say "  3) Exit"
    say ""
    read -p "Choice [1-3]: " -n 1 -r
    echo ""

    case "$REPLY" in
      1)
        say "â–¸ Initializing current directory..."
        git init
        "$ROOT/setup/existing_repo_setup.sh"
        ;;
      2)
        say "â–¸ Starting repository wizard..."
        "$ROOT/setup/repo_wizard.sh"
        ;;
      *)
        say "Setup cancelled."
        exit 0
        ;;
    esac
  fi

  say ""
  say "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  say "  SETUP COMPLETE"
  say "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  say ""
  say "  Next Steps"
  say "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  say "  1. dp init       â†’ Initialize project settings"
  say "  2. dp palette    â†’ Browse available commands"
  say "  3. dp review     â†’ Review your changes with AI"
  say ""
}

cmd_doctor() {
  # Run system health check
  if [[ -x "$ROOT/scripts/doctor.sh" ]]; then
    "$ROOT/scripts/doctor.sh" "$@"
  else
    say "Error: doctor.sh not found"
    exit 1
  fi
}

case "${1:-}" in
  setup)  shift; cmd_setup "$@";;
  doctor) shift; cmd_doctor "$@";;
  init)   shift; cmd_init "$@";;
  tickets)shift; cmd_tickets "$@";;
  review) shift; cmd_review "$@";;
  project)shift; cmd_project "$@";;
  palette)shift; cmd_palette "$@";;
  -h|--help|"")
    cat <<'HELP'
DevPilot - Unified AI Development Interface

Setup & Configuration:
  dp setup [URL]       # Smart setup - detects new vs existing repo
  dp doctor            # System health check and diagnostics
  dp init              # Initialize project after setup
  dp project           # Create/show devpilot.project.yml

Development Workflow:
  dp palette [query]   # Interactive command browser (requires fzf)
  dp tickets           # Generate structured backlog from code
  dp review            # AI review of your changes
  dp review --preview  # Review with preview environment context

Examples:
  dp setup                                    # Setup current directory
  dp setup https://github.com/user/repo      # Clone and setup
  dp doctor                                   # Check system readiness
  dp init                                     # Initialize after setup
  dp palette test                             # Find test commands

Advanced (via just):
  just preview         # Start preview environment
  just preview-logs    # View preview logs
  just preview-stop    # stop preview environment
  just review-preview  # AI review with full preview context
  just palette         # interactive command palette
  just commands        # generate command registry

Env: AI_MODEL_* override model names; TIMEOUT_SECS limits long runs
HELP
    ;;
  *) echo "unknown subcommand: $1" >&2; exit 2;;
esac
