#!/usr/bin/env bash
# DevPilot meta-CLI: beautiful defaults for init, tickets, and review.
set -euo pipefail
ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
SHIM="$ROOT/tools/ai_shim.sh"
ART="$ROOT/artifacts"
mkdir -p "$ART"

say() { printf "%s\n" "$*"; }
have(){ command -v "$1" >/dev/null 2>&1; }

pick_cli() {
  # Prefer anthropic, then codex, gemini, grok
  for p in anthropic codex gemini grok; do
    if have "$p"; then echo "$p"; return; fi
  done
  echo ""
}

cmd_init() {
  say "‚ñ∏ Running doctor ‚Ä¶"
  if [[ -x "$ROOT/scripts/doctor.sh" ]]; then "$ROOT/scripts/doctor.sh" || true; fi

  # Check for project file
  local project_file=""
  for pf in devpilot.project.yml devpilot.project.yaml .devpilot.yml .devpilot.yaml; do
    if [[ -f "$pf" ]]; then
      project_file="$pf"
      say "‚ñ∏ Found project profile: $pf"
      break
    fi
  done

  if [[ -n "$project_file" ]]; then
    say "‚ñ∏ Applying profile from $project_file ‚Ä¶"
    if [[ -x "$ROOT/scripts/apply_profile.sh" ]]; then "$ROOT/scripts/apply_profile.sh" || true; fi
  else
    say "‚ñ∏ No project file found. Using defaults (skill=l1, phase=mvp) ‚Ä¶"
    say "  üí° Tip: Create devpilot.project.yml for zero-friction setup"
    if [[ -x "$ROOT/scripts/apply_profile.sh" ]]; then "$ROOT/scripts/apply_profile.sh" --skill l1 --phase mvp || true; fi
  fi

  say "‚ñ∏ Building system/active.md ‚Ä¶"
  if [[ -x "$ROOT/scripts/system_build.sh" ]]; then "$ROOT/scripts/system_build.sh" || true; fi
  say "‚ñ∏ Quick repo review ‚Ä¶"
  if grep -q '^repo-review:' "$ROOT/Justfile" 2>/dev/null; then just repo-review || true; fi
  say
  say "‚úÖ Ready. Next:"
  say "  1) dp tickets   # structured backlog (JSON/CSV)"
  say "  2) dp review    # AI review of your local diff"
  say "  3) just dev     # your project's dev server (if defined)"
}

build_tickets_prompt() {
  local out="$ART/tickets_prompt.txt"
  if [[ -f "$ROOT/.claude/commands/tickets-from-code.md" ]]; then
    cat "$ROOT/.claude/commands/tickets-from-code.md" > "$out"
  else
    cat > "$out" <<'EOF'
ROLE: Senior engineer. Produce a prioritized backlog as strict JSON (see schema in docs).
SCOPE: entire repo; include security, tests, docs, observability.
OUTPUT: JSON only (no markdown), then I will convert to CSV.
EOF
  fi
  echo "$out"
}

extract_json() {
  # Pull JSON object from noisy model output
  awk 'BEGIN{in=0} /^[[:space:]]*{/ && !in {in=1} in{print}' | \
  awk 'BEGIN{c=0} {print; for(i=1;i<=length($0);i++){ch=substr($0,i,1); if(ch=="{")c++; else if(ch=="}")c--;}} END{exit c!=0}'
}

cmd_tickets() {
  local sys="$ROOT/system/active.md"
  [[ -f "$sys" ]] || { say "error: $sys not found. Run dp init."; exit 1; }
  local prompt; prompt="$(build_tickets_prompt)"
  local raw="$ART/tickets_raw.txt" json="$ART/tickets.json" csv="$ART/tickets.csv"
  : > "$raw"

  say "‚ñ∏ Generating tickets (CLI fallback: codex‚Üíclaude‚Üígemini‚Üígrok) ‚Ä¶"
  # Try providers via shim; neutral if none exist
  "$SHIM" --provider codex  --model "${AI_MODEL_CODEX:-codex-latest}"             --prompt-file "$prompt" > "$raw" 2> "$ART/tickets_codex.err"  || true
  [[ -s "$raw" ]] || "$SHIM" --provider claude --model "${AI_MODEL_CLAUDE:-claude-3-7-sonnet-20250219}" --prompt-file "$prompt" > "$raw" 2> "$ART/tickets_claude.err" || true
  [[ -s "$raw" ]] || "$SHIM" --provider gemini --model "${AI_MODEL_GEMINI:-gemini-1.5-pro-latest}"     --prompt-file "$prompt" > "$raw" 2> "$ART/tickets_gemini.err" || true
  [[ -s "$raw" ]] || "$SHIM" --provider grok   --model "${AI_MODEL_GROK:-grok-2-latest}"               --prompt-file "$prompt" > "$raw" 2> "$ART/tickets_grok.err"   || true

  if [[ ! -s "$raw" ]]; then
    say "‚ÑπÔ∏è  No AI CLI produced output. Install anthropic/codex/gemini/grok CLIs or run in CI with those CLIs."
    exit 0
  fi
  if extract_json < "$raw" > "$json"; then
    jq -r '
      .tickets[]
      | [
          .id, .title, .type, .priority, .effort,
          (.labels // [] | join("|")), (.assignee // ""),
          (.dependencies // [] | join("|")),
          (.notes // "" | gsub("[\r\n]+";" ")),
          (.acceptance_criteria // [] | join("; "))
        ] | @csv
    ' "$json" > "$csv" || true
    say "‚úÖ Wrote:"
    say "   - $json"
    [[ -s "$csv" ]] && say "   - $csv"
  else
    say "‚ö†Ô∏è  Could not find valid JSON in model output. Try a smaller scope or a different CLI."
    exit 0
  fi
}

cmd_review() {
  local sys="$ROOT/system/active.md"
  [[ -f "$sys" ]] || { say "error: $sys not found. Run dp init."; exit 1; }
  local base="${BASE_BRANCH:-main}"
  local with_preview="${1:-}"

  # Check for preview flag
  if [[ "$with_preview" == "--preview" ]]; then
    say "‚ñ∏ Review will include preview logs"
  fi

  git fetch --no-tags origin "$base" --depth=1 || true
  git diff --unified=1 --minimal --no-color "origin/$base"...HEAD > "$ART/review_diff.patch" || true
  local lines; lines=$(wc -l < "$ART/review_diff.patch" || echo 0)
  if [[ "$lines" -gt 6000 ]]; then head -n 6000 "$ART/review_diff.patch" > "$ART/review_diff.patch.head" && mv "$ART/review_diff.patch.head" "$ART/review_diff.patch"; fi

  # Analyze risk if tool exists
  local risk_tags=""
  local risk_prelude=""
  if [[ -x "$ROOT/tools/diff_risk.sh" ]]; then
    risk_tags=$("$ROOT/tools/diff_risk.sh" "$ART/review_diff.patch" tags 2>/dev/null || echo "")
    if [[ -n "$risk_tags" ]]; then
      say "‚ñ∏ Risk analysis: $risk_tags"

      # Build risk-aware prelude
      risk_prelude="RISK: "
      if [[ "$risk_tags" =~ "level:critical" ]]; then
        risk_prelude+="‚õî CRITICAL changes detected. "
      elif [[ "$risk_tags" =~ "level:high" ]]; then
        risk_prelude+="üî¥ HIGH risk changes. "
      fi

      # Add specific risk focus
      [[ "$risk_tags" =~ "risk:auth" ]] && risk_prelude+="Auth flows modified - check for bypasses. "
      [[ "$risk_tags" =~ "risk:db" ]] && risk_prelude+="Database changes - verify migrations and queries. "
      [[ "$risk_tags" =~ "risk:payment" ]] && risk_prelude+="Payment code - audit thoroughly. "
      [[ "$risk_tags" =~ "risk:security" ]] && risk_prelude+="Security-sensitive - check for vulnerabilities. "
      [[ "$risk_tags" =~ "risk:api" ]] && risk_prelude+="API changes - verify backwards compatibility. "

      risk_prelude+="\n"
    fi
  fi

  # Collect preview logs if requested
  local preview_context=""
  if [[ "$with_preview" == "--preview" ]]; then
    say "‚ñ∏ Collecting preview logs..."
    if [[ -x "$ROOT/tools/preview_logs.sh" ]]; then
      preview_context=$("$ROOT/tools/preview_logs.sh" 200 context 2>/dev/null || echo "")
    elif docker ps -q -f "name=preview-" > /dev/null 2>&1; then
      preview_context=$(docker logs preview-app-local --tail=200 2>&1 | grep -E "(ERROR|WARN|Exception)" | tail -50 || echo "")
    fi

    if [[ -n "$preview_context" ]]; then
      say "‚ñ∏ Found preview context (errors/warnings will be included)"
    fi
  fi

  {
    [[ -n "$risk_prelude" ]] && echo -e "$risk_prelude"
    echo "ROLE: Senior code reviewer. Produce concise, file-scoped bullets with suggested changes."
    if [[ -n "$preview_context" ]]; then
      echo "CONTEXT: Preview environment is running. Review logs for runtime issues."
      echo ""
      echo "=== PREVIEW LOGS ==="
      echo "$preview_context" | head -50
      echo "=== END LOGS ==="
      echo ""
    fi
    echo "HINT: If diff seems truncated, outline issues file-by-file; ask for a follow-up on specific files as needed."
    echo "DIFF:"; cat "$ART/review_diff.patch"
  } > "$ART/review_prompt.txt"

  "$SHIM" --provider claude --model "${AI_MODEL_CLAUDE:-claude-3-7-sonnet-20250219}" --prompt-file "$ART/review_prompt.txt" > "$ART/review_local.txt" 2> "$ART/review_claude.err" || true
  [[ -s "$ART/review_local.txt" ]] || "$SHIM" --provider codex  --model "${AI_MODEL_CODEX:-codex-latest}"             --prompt-file "$ART/review_prompt.txt" > "$ART/review_local.txt" 2> "$ART/review_codex.err"  || true
  [[ -s "$ART/review_local.txt" ]] || "$SHIM" --provider gemini --model "${AI_MODEL_GEMINI:-gemini-1.5-pro-latest}"     --prompt-file "$ART/review_prompt.txt" > "$ART/review_local.txt" 2> "$ART/review_gemini.err" || true
  [[ -s "$ART/review_local.txt" ]] || "$SHIM" --provider grok   --model "${AI_MODEL_GROK:-grok-2-latest}"               --prompt-file "$ART/review_prompt.txt" > "$ART/review_local.txt" 2> "$ART/review_grok.err"   || true

  if [[ -s "$ART/review_local.txt" ]]; then
    say "‚úÖ Wrote: $ART/review_local.txt"
  else
    say "‚ÑπÔ∏è  No AI CLI produced output. Install an AI CLI to use dp review."
  fi
}

cmd_project() {
  # Create or show project file
  if [[ -f devpilot.project.yml ]]; then
    say "‚úì Project file exists: devpilot.project.yml"
    say ""
    say "Current settings:"
    grep -E "^  (skill|phase|primary):" devpilot.project.yml | head -5
  else
    say "Creating devpilot.project.yml with sensible defaults..."

    # Detect current project name
    local project_name=$(basename "$PWD")

    # Create from template
    if [[ -f "$ROOT/templates/devpilot.project.yml" ]]; then
      sed "s/\${PROJECT_NAME:-MyProject}/$project_name/g" \
        "$ROOT/templates/devpilot.project.yml" > devpilot.project.yml
      say "‚úÖ Created devpilot.project.yml"
      say ""
      say "Next steps:"
      say "  1) Edit devpilot.project.yml to customize"
      say "  2) Run: dp init"
      say ""
      say "Key settings to review:"
      grep -E "^  (skill|phase|primary):" devpilot.project.yml | head -5
    else
      # Minimal fallback
      cat > devpilot.project.yml <<EOF
# DevPilot Project Profile
project:
  name: $project_name

profile:
  skill: l2          # l1=beginner, l2=intermediate, l3=expert
  phase: mvp         # poc, mvp, beta, scale
  teach_mode: false

personas:
  primary: pragmatic-coder

ci:
  gates:
    lint: required
    tests: required
    coverage: advisory
EOF
      say "‚úÖ Created minimal devpilot.project.yml"
    fi
  fi
}

cmd_palette() {
  # Interactive command palette with fzf
  local query="${1:-}"

  # Check for fzf
  if ! have fzf; then
    say "‚ö†Ô∏è  fzf not found. Install with:"
    say "  brew install fzf    # macOS"
    say "  apt install fzf     # Ubuntu/Debian"
    say ""
    say "Or use: just commands  # to view command list"
    exit 1
  fi

  # Generate command registry if needed
  local registry="$ART/commands.json"
  if [[ ! -f "$registry" ]] || [[ "$ROOT/scripts/generate_command_registry.sh" -nt "$registry" ]]; then
    say "‚ñ∏ Generating command registry..."
    if [[ -x "$ROOT/scripts/generate_command_registry.sh" ]]; then
      "$ROOT/scripts/generate_command_registry.sh" "$ART/commands.md" "$registry" >/dev/null 2>&1
    fi
  fi

  # Build command list for fzf
  local commands_file="$ART/palette_commands.txt"
  if [[ -f "$registry" ]]; then
    jq -r '.commands[] | "\(.command) :: \(.description) [\(.category)]"' "$registry" > "$commands_file"
  else
    # Fallback to basic commands
    cat > "$commands_file" <<'EOF'
dp init :: Initialize project
dp tickets :: Generate backlog
dp review :: Review code changes
dp palette :: Command palette
just dev :: Start dev server
just test :: Run tests
just lint :: Run linters
just fmt :: Format code
EOF
  fi

  # Interactive selection with fzf
  local selected
  if [[ -n "$query" ]]; then
    selected=$(cat "$commands_file" | fzf --query="$query" --select-1 --exit-0 \
      --prompt="DevPilot ‚ñ∏ " \
      --header="Select command (ESC to cancel)" \
      --preview-window=hidden \
      --height=40% \
      --layout=reverse \
      --border=rounded)
  else
    selected=$(cat "$commands_file" | fzf \
      --prompt="DevPilot ‚ñ∏ " \
      --header="Select command (ESC to cancel)" \
      --preview-window=hidden \
      --height=40% \
      --layout=reverse \
      --border=rounded)
  fi

  if [[ -n "$selected" ]]; then
    # Extract command from selection
    local cmd="${selected%% ::*}"
    say "‚ñ∏ Running: $cmd"
    say ""

    # Execute the command
    eval "$cmd"
  fi
}

case "${1:-}" in
  init)   shift; cmd_init "$@";;
  tickets)shift; cmd_tickets "$@";;
  review) shift; cmd_review "$@";;
  project)shift; cmd_project "$@";;
  palette)shift; cmd_palette "$@";;
  -h|--help|"")
    cat <<'HELP'
DevPilot meta-CLI
  dp init              # doctor ‚Üí profile ‚Üí build system ‚Üí quick repo review
  dp project           # create/show devpilot.project.yml (zero-friction defaults)
  dp tickets           # structured backlog (JSON ‚Üí CSV), CLI-first, strict schema
  dp review            # local AI review of your diff (neutral if no CLIs)
  dp review --preview  # review with preview environment logs for context
  dp palette [query]   # interactive command palette (requires fzf)

Commands via just:
  just preview         # start preview environment (Docker Compose)
  just preview-logs    # view preview logs
  just preview-stop    # stop preview environment
  just review-preview  # AI review with full preview context
  just palette         # interactive command palette
  just commands        # generate command registry

Env: AI_MODEL_* override model names; TIMEOUT_SECS limits long runs
HELP
    ;;
  *) echo "unknown subcommand: $1" >&2; exit 2;;
esac
