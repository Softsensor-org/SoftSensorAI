#!/usr/bin/env bash
# DevPilot Agentic Coding Assistant - P1 Enhanced
set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
SHIM="$ROOT/tools/ai_shim.sh"
SYS="$ROOT/system/active.md"
ART="$ROOT/artifacts"
mkdir -p "$ART"

say() { printf "%s\n" "$*"; }
have() { command -v "$1" >/dev/null 2>&1; }
now() { date -Iseconds 2>/dev/null || date '+%Y-%m-%dT%H:%M:%S'; }

# Redact sensitive information from diffs before sending to AI or storing
redact_secrets() {
  # Patterns for common secrets and sensitive data
  sed -E \
    -e 's/(api[_-]?key|token|secret|password|passwd|pwd|auth|credential)[[:space:]]*[=:][[:space:]]*["\047]?[^"\047[:space:]]*/\1=REDACTED/gi' \
    -e 's/(bearer|authorization)[[:space:]]*[:][[:space:]]*[^[:space:]]*/\1: REDACTED/gi' \
    -e 's/[A-Za-z0-9+\/]{40,}=[=]?/REDACTED_BASE64/g' \
    -e 's/sk-[a-zA-Z0-9]{48}/sk-REDACTED/g' \
    -e 's/ghp_[a-zA-Z0-9]{36}/ghp_REDACTED/g' \
    -e 's/ghs_[a-zA-Z0-9]{36}/ghs_REDACTED/g' \
    -e 's/glpat-[a-zA-Z0-9]{20}/glpat-REDACTED/g' \
    -e 's/\b[A-F0-9]{64}\b/REDACTED_SHA256/gi' \
    -e 's/-----BEGIN[^-]*KEY-----[^-]*-----END[^-]*KEY-----/-----BEGIN KEY-----\nREDACTED\n-----END KEY-----/g' \
    -e 's/ssh-[a-z0-9]* [^ ]*/ssh-TYPE REDACTED/g' \
    -e 's/[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}/REDACTED_UUID/gi'
}

extract_json() {
  awk 'BEGIN{in=0} /^[[:space:]]*{/ && !in {in=1} in{print}' | \
  awk 'BEGIN{c=0} {print; for(i=1;i<=length($0);i++){ch=substr($0,i,1); if(ch=="{")c++; else if(ch=="}")c--;}} END{exit c!=0}'
}

ensure_sys() {
  [[ -f "$SYS" ]] || { say "error: $SYS not found. Run dp init."; exit 1; }
}

id_new() {
  local base="${1:-main}"
  local id
  id="task-$(date +%Y%m%d%H%M%S)-$(head -c4 /dev/urandom | xxd -p 2>/dev/null || echo $$)"
  echo "$id|$base"
}

sandbox_create() {
  local id="$1" base="$2"
  local wt="$ART/agent/$id/work"
  mkdir -p "$ART/agent/$id"
  git fetch --no-tags origin "$base" --depth=1 || true
  if [ ! -d "$wt/.git" ]; then
    git worktree add -B "agent/$id" "$wt" "origin/$base"
  fi
  echo "$wt"
}

# --- Context packer (lightweight) ---
context_pack() {
  local wt="$1" out="$ART/agent/$TASK_ID/context_pack.txt"
  (
    cd "$wt" || exit 0
    echo "== tree (top 200) =="; git ls-files | head -n 200
    echo; echo "== largest files =="; (du -ah . | sort -hr | head -n 25) 2>/dev/null || true
    echo; echo "== json/yaml (top 40) =="; (find . -type f \( -name "*.json" -o -name "*.yml" -o -name "*.yaml" \) | head -n 40) 2>/dev/null || true
    echo; echo "== last 20 package scripts =="; \
      grep -nE '"(scripts|dev|build|test|lint)"' package.json 2>/dev/null | head -n 20 || true
  ) > "$out"
  echo "$out"
}

# --- Verify (build/test/lint/security -> verify.json) ---
verify_repo() {
  local wt="$1"; shift || true
  local out="$ART/agent/$TASK_ID/verify.json"
  local ok_build=true ok_test=true ok_lint=true ok_sec=true
  local t0
  t0=$(date +%s)

  # Parallel execution with background jobs
  local build_pid="" test_pid="" lint_pid="" sec_pid=""

  pushd "$wt" >/dev/null

  # Start build in background
  (
    if have just && grep -q "^build:" Justfile 2>/dev/null; then
      just build > "$ART/agent/$TASK_ID/build.log" 2>&1 || echo "BUILD_FAILED" > "$ART/agent/$TASK_ID/build.status"
    elif have npm; then
      npm run -s build > "$ART/agent/$TASK_ID/build.log" 2>&1 || echo "BUILD_FAILED" > "$ART/agent/$TASK_ID/build.status"
    fi
  ) &
  build_pid=$!

  # Prepare test arguments for targeted testing
  local pytest_args="" jest_args="" cov=0 cov_base=0 cov_delta=0
  if [ -n "${CHANGED_FILES:-}" ]; then
    # Python: derive a -k pattern from changed module basenames
    if command -v pytest >/dev/null 2>&1; then
      local pat=""
      while IFS= read -r f; do
        base="${f##*/}"; base="${base%.*}"
        [ -n "$pat" ] && pat="$pat or "
        pat="$pat$base"
      done <<EOF
$CHANGED_FILES
EOF
      [ -n "$pat" ] && pytest_args="-k \"$pat\""
    fi
    # JS: use --findRelatedTests
    if command -v jest >/dev/null 2>&1; then
      jest_args="--findRelatedTests $(echo "$CHANGED_FILES" | tr '\n' ' ')"
    fi
  fi

  # Start tests in background
  (
    if command -v pytest >/dev/null 2>&1; then
      if pytest -q --help 2>/dev/null | grep -q -- --cov; then
        # Get base SHA for caching
        local base_sha
        base_sha=$(git rev-parse "origin/${BASE_BRANCH:-main}" 2>/dev/null || echo "unknown")
        local baseline_cache="$ART/agent/_baseline/${base_sha}/coverage.json"

        # Use cached baseline if available, otherwise generate
        if [ -f "$baseline_cache" ]; then
          cp "$baseline_cache" "$ART/agent/$TASK_ID/coverage.base.json"
        else
          # Generate baseline coverage
          mkdir -p "$(dirname "$baseline_cache")"
          pytest -q --maxfail=1 --cov=. --cov-report json:"$ART/agent/$TASK_ID/coverage.base.json" >/dev/null 2>&1 || true
          # Cache for future runs
          cp "$ART/agent/$TASK_ID/coverage.base.json" "$baseline_cache" 2>/dev/null || true
        fi
        eval pytest -q --maxfail=1 --cov=. --cov-report json:"$ART/agent/$TASK_ID/coverage.json" "$pytest_args" > "$ART/agent/$TASK_ID/test.log" 2>&1 || echo "TEST_FAILED" > "$ART/agent/$TASK_ID/test.status"
        echo "$ART/agent/$TASK_ID/coverage.json" > "$ART/agent/$TASK_ID/test.coverage"
      else
        eval pytest -q "$pytest_args" > "$ART/agent/$TASK_ID/test.log" 2>&1 || echo "TEST_FAILED" > "$ART/agent/$TASK_ID/test.status"
      fi
    # Else try jest with coverage
    elif command -v jest >/dev/null 2>&1; then
      mkdir -p "$ART/agent/$TASK_ID/coverage"
      eval jest --coverage --coverageReporters=json-summary --coverageDirectory "$ART/agent/$TASK_ID/coverage" "$jest_args" > "$ART/agent/$TASK_ID/test.log" 2>&1 || echo "TEST_FAILED" > "$ART/agent/$TASK_ID/test.status"
      echo "$ART/agent/$TASK_ID/coverage/coverage-summary.json" > "$ART/agent/$TASK_ID/test.coverage.jest"
    elif have just && grep -q "^test:" Justfile 2>/dev/null; then
      just test > "$ART/agent/$TASK_ID/test.log" 2>&1 || echo "TEST_FAILED" > "$ART/agent/$TASK_ID/test.status"
    elif have npm; then
      npm test -s > "$ART/agent/$TASK_ID/test.log" 2>&1 || echo "TEST_FAILED" > "$ART/agent/$TASK_ID/test.status"
    fi
  ) &
  test_pid=$!

  # Start lint in background
  (
    if have just && grep -q "^lint:" Justfile 2>/dev/null; then
      just lint > "$ART/agent/$TASK_ID/lint.log" 2>&1 || echo "LINT_FAILED" > "$ART/agent/$TASK_ID/lint.status"
    elif have npm; then
      npm run -s lint > "$ART/agent/$TASK_ID/lint.log" 2>&1 || echo "LINT_FAILED" > "$ART/agent/$TASK_ID/lint.status"
    fi
  ) &
  lint_pid=$!

  # Start security scan in background
  (
    local semgrep_high=0 trivy_high=0 leaks=0

    # Semgrep scan
    if have semgrep; then
      semgrep --json -q --config=auto > "$ART/agent/$TASK_ID/semgrep.json" 2>/dev/null || true
      semgrep_high=$(jq '[.results[]|select(.extra.severity=="ERROR")] | length' "$ART/agent/$TASK_ID/semgrep.json" 2>/dev/null || echo 0)
    fi

    # Trivy scan
    if have trivy; then
      trivy fs --security-checks vuln --quiet --format json . > "$ART/agent/$TASK_ID/trivy.json" 2>/dev/null || true
      trivy_high=$(jq '[.Results[].Vulnerabilities[]?|select(.Severity=="HIGH" or .Severity=="CRITICAL")] | length' "$ART/agent/$TASK_ID/trivy.json" 2>/dev/null || echo 0)
    fi

    # Gitleaks scan
    if have gitleaks; then
      gitleaks detect --quiet --no-git --format json > "$ART/agent/$TASK_ID/gitleaks.json" 2>/dev/null || true
      leaks=$(jq '.[]|length' "$ART/agent/$TASK_ID/gitleaks.json" 2>/dev/null || echo 0)
    fi

    # Save security results
    echo "{\"semgrep_high\": $semgrep_high, \"trivy_high\": $trivy_high, \"leaks\": $leaks}" > "$ART/agent/$TASK_ID/security.results"
    [ "$semgrep_high" -gt 0 ] || [ "$trivy_high" -gt 0 ] || [ "$leaks" -gt 0 ] && echo "SEC_FAILED" > "$ART/agent/$TASK_ID/security.status"
  ) &
  sec_pid=$!

  # Wait for all background jobs to complete
  [ -n "$build_pid" ] && wait "$build_pid" 2>/dev/null
  [ -n "$test_pid" ] && wait "$test_pid" 2>/dev/null
  [ -n "$lint_pid" ] && wait "$lint_pid" 2>/dev/null
  [ -n "$sec_pid" ] && wait "$sec_pid" 2>/dev/null

  popd >/dev/null

  # Check status files
  [ -f "$ART/agent/$TASK_ID/build.status" ] && ok_build=false
  [ -f "$ART/agent/$TASK_ID/test.status" ] && ok_test=false
  [ -f "$ART/agent/$TASK_ID/lint.status" ] && ok_lint=false
  [ -f "$ART/agent/$TASK_ID/security.status" ] && ok_sec=false

  # Load coverage results
  local cov=0 cov_base=0 cov_delta=0
  if [ -f "$ART/agent/$TASK_ID/test.coverage" ]; then
    local cov_file
    cov_file=$(cat "$ART/agent/$TASK_ID/test.coverage")
    cov=$(jq -r '.totals.percent_covered // 0' "$cov_file" 2>/dev/null || echo 0)
    cov_base=$(jq -r '.totals.percent_covered // 0' "$ART/agent/$TASK_ID/coverage.base.json" 2>/dev/null || echo 0)
    cov_delta=$(awk -v a="$cov" -v b="$cov_base" 'BEGIN{printf "%.2f", a-b}')
  elif [ -f "$ART/agent/$TASK_ID/test.coverage.jest" ]; then
    local cov_file
    cov_file=$(cat "$ART/agent/$TASK_ID/test.coverage.jest")
    cov=$(jq -r '.total.lines.pct // 0' "$cov_file" 2>/dev/null || echo 0)
    if [ -f "$ART/agent/$TASK_ID/coverage.base.json" ]; then
      cov_base=$(jq -r '.total.lines.pct // 0' "$ART/agent/$TASK_ID/coverage.base.json" 2>/dev/null || echo 0)
      cov_delta=$(awk -v a="$cov" -v b="$cov_base" 'BEGIN{printf "%.2f", a-b}')
    else
      cp "$cov_file" "$ART/agent/$TASK_ID/coverage.base.json" 2>/dev/null || true
    fi
  fi

  # Load security results
  local semgrep_high=0 trivy_high=0 leaks=0
  if [ -f "$ART/agent/$TASK_ID/security.results" ]; then
    semgrep_high=$(jq -r '.semgrep_high // 0' "$ART/agent/$TASK_ID/security.results" 2>/dev/null || echo 0)
    trivy_high=$(jq -r '.trivy_high // 0' "$ART/agent/$TASK_ID/security.results" 2>/dev/null || echo 0)
    leaks=$(jq -r '.leaks // 0' "$ART/agent/$TASK_ID/security.results" 2>/dev/null || echo 0)
  fi
  local t1
  t1=$(date +%s)
  cat >"$out" <<JSON
{
  "build": {"ok": $ok_build},
  "tests": {"ok": $ok_test, "coverage_pct": $cov, "coverage_base_pct": $cov_base, "coverage_delta_pct": $cov_delta},
  "lint":  {"ok": $ok_lint},
  "security": {"ok": $ok_sec, "semgrep_high": $semgrep_high, "trivy_high": $trivy_high, "gitleaks": $leaks},
  "time_s": $((t1-t0))
}
JSON
  echo "$out"
}

# --- Codemod engine (prefers comby; falls back to literal edits) ---
apply_step() {
  local wt="$1" step_json="$2"
  local method files count
  method=$(echo "$step_json" | jq -r '.method // "edit"')
  files=$(echo "$step_json" | jq -r '.files[]?')
  count=0
  case "$method" in
    new_file)
      while IFS= read -r f; do
        [ -z "$f" ] && continue
        mkdir -p "$wt/$(dirname "$f")"
        # content if provided, else TODO stub
        content=$(echo "$step_json" | jq -r '.content // empty')
        if [ -n "$content" ]; then printf "%s\n" "$content" > "$wt/$f"; else printf "// TODO: agent created file: %s\n" "$f" > "$wt/$f"; fi
        count=$((count+1))
      done <<< "$files"
      ;;
    codemod)
      local has_comby=0
      command -v comby >/dev/null 2>&1 && has_comby=1
      local match rewrite language
      match=$(echo "$step_json" | jq -r '.comby.match // empty')
      rewrite=$(echo "$step_json" | jq -r '.comby.rewrite // empty')
      language=$(echo "$step_json" | jq -r '.comby.language // "."')
      if [ "$has_comby" -eq 1 ] && [ -n "$match" ] && [ -n "$rewrite" ]; then
        while IFS= read -r f; do
          [ -z "$f" ] && continue
          comby -in-place -matcher "$language" "$match" "$rewrite" -- "$wt/$f" >/dev/null 2>&1 || true
          count=$((count+1))
        done <<< "$files"
      else
        # fallback to literal replacements array
        local edits; edits=$(echo "$step_json" | jq -c '.edits[]?' 2>/dev/null || true)
        if [ -n "$edits" ]; then
          while IFS= read -r e; do
            local f search replace
            f=$(echo "$e" | jq -r '.file'); search=$(echo "$e" | jq -r '.search'); replace=$(echo "$e" | jq -r '.replace')
            [ -z "$f" ] && continue
            # BSD-safe sed
            sed -i'' -e "s|${search//|/\\|}|${replace//|/\\|}|g" "$wt/$f" 2>/dev/null || true
            count=$((count+1))
          done <<< "$edits"
        fi
      fi
      ;;
    edit|*)
      # literal edits only
      local edits; edits=$(echo "$step_json" | jq -c '.edits[]?' 2>/dev/null || true)
      if [ -n "$edits" ]; then
        while IFS= read -r e; do
          local f search replace
          f=$(echo "$e" | jq -r '.file'); search=$(echo "$e" | jq -r '.search'); replace=$(echo "$e" | jq -r '.replace')
          [ -z "$f" ] && continue
          sed -i'' -e "s|${search//|/\\|}|${replace//|/\\|}|g" "$wt/$f" 2>/dev/null || true
          count=$((count+1))
        done <<< "$edits"
      fi
      ;;
  esac
  echo "$count"
}

cmd_new() {
  ensure_sys
  local GOAL="" BASE="${BASE_BRANCH:-main}"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --goal) GOAL="${2:-}"; shift 2;;
      --base) BASE="${2:-}"; shift 2;;
      *)
        # If arg is a readable file, use its contents as the goal
        if [[ -f "$1" && -r "$1" ]]; then
          GOAL="$(cat "$1")"
        else
          GOAL="$1"
        fi
        shift;;
    esac
  done
  [[ -n "${GOAL}" ]] || { echo "usage: dp agent new --goal '<goal>' [--base main]  OR  dp agent new <spec-file>"; exit 2; }

  # Generate unique task ID
  IFS='|' read -r TASK_ID BASE <<<"$(id_new "$BASE")"
  local dir="$ART/agent/$TASK_ID"
  mkdir -p "$dir"
  echo "$GOAL" > "$dir/spec.md"
  cat > "$dir/run.json" <<JSON
{"task_id":"$TASK_ID","base":"$BASE","goal":"$GOAL","created":"$(now)"}
JSON
  say "✅ Task created: $TASK_ID"
  say "  Goal: $GOAL"
  say "  Base: $BASE"
  say "  Artifacts: $dir/"
  say "  Next: dp agent run --id $TASK_ID"
}

cmd_run() {
  ensure_sys
  local TASK_ID="" AUTO=0 BASE="${BASE_BRANCH:-main}" LOOPS=1
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --id) TASK_ID="${2:-}"; shift 2;;
      --auto) AUTO=1; shift;;
      --loops) LOOPS="${2:-1}"; shift 2;;
      --base) BASE="${2:-}"; shift 2;;
      *) echo "unknown flag: $1"; exit 2;;
    esac
  done
  [[ -n "${TASK_ID}" ]] || { echo "usage: dp agent run --id <task_id> [--auto] [--loops N]"; exit 2; }
  local dir="$ART/agent/$TASK_ID"; [[ -d "$dir" ]] || { echo "error: task not found: $TASK_ID"; exit 2; }

  # Add locking to prevent concurrent operations
  local LOCK_DIR="$ART/agent/.locks"
  mkdir -p "$LOCK_DIR"
  local LOCK_FILE="$LOCK_DIR/${TASK_ID}.lock"

  # Clean up lock on exit
  trap 'rm -f "$LOCK_FILE"' EXIT

  # Try to acquire lock (using noclobber for atomicity)
  if ! (set -o noclobber; echo $$ > "$LOCK_FILE") 2>/dev/null; then
    local existing_pid=$(cat "$LOCK_FILE" 2>/dev/null || echo "unknown")
    echo "error: Task $TASK_ID is already being processed (PID: $existing_pid)"
    echo "If this is stale, remove: $LOCK_FILE"
    exit 1
  fi

  local wt; wt="$(sandbox_create "$TASK_ID" "$BASE")"
  say "▸ Sandbox: $wt (branch agent/$TASK_ID)"

  # PLAN
  local plan_prompt="$dir/plan_prompt.txt" plan_raw="$dir/plan_raw.txt" plan_json="$dir/plan.json"
  {
    echo "SPEC:"; cat "$dir/spec.md"
    echo; echo "INSTRUCTIONS:"; cat "$ROOT/.claude/commands/agent/plan.md"
  } > "$plan_prompt"

  say "▸ Generating plan..."
  "$SHIM" --provider claude --model "${AI_MODEL_CLAUDE:-claude-3-7-sonnet-20250219}" --prompt-file "$plan_prompt" > "$plan_raw" 2>/dev/null || \
  "$SHIM" --provider codex  --model "${AI_MODEL_CODEX:-codex-latest}" --prompt-file "$plan_prompt" > "$plan_raw" 2>/dev/null || \
  "$SHIM" --provider gemini --model "${AI_MODEL_GEMINI:-gemini-1.5-pro-latest}" --prompt-file "$plan_prompt" > "$plan_raw" 2>/dev/null || \
  "$SHIM" --provider grok   --model "${AI_MODEL_GROK:-grok-2-latest}" --prompt-file "$plan_prompt" > "$plan_raw" 2>/dev/null || true

  if extract_json < "$plan_raw" > "$plan_json"; then
    say "▸ Plan JSON written: $plan_json"
  else
    cp "$plan_raw" "$dir/plan.md"
    say "⚠️  Plan is not JSON; saved as $dir/plan.md (continue manually)."
  fi

  # P1: Codemod-first apply of steps (if JSON) with small repair loops
  local attempt=1
  while [ "$attempt" -le "$LOOPS" ]; do
    say "▸ Attempt $attempt/$LOOPS"
    # Context pack (helps humans & future prompts)
    context_pack "$wt" >/dev/null || true

    if [ -f "$plan_json" ]; then
      local total=0
      while IFS= read -r step; do
        changed=$(apply_step "$wt" "$step")
        total=$((total + changed))
      done < <(jq -c '.steps[]?' "$plan_json" 2>/dev/null)
      say "▸ Applied ~$total codemod/edit actions"
    fi

    # Stage changes & compute changed file list for targeted tests
    (cd "$wt" && git add -A >/dev/null 2>&1) || true
    local changed_list
    changed_list="$(cd "$wt" && git status --porcelain | awk '{print $2}')" || true
    export CHANGED_FILES="$changed_list"
    export TASK_ID

    # Verify
    local vout; vout="$(verify_repo "$wt")"
    say "▸ Verify report: $vout"
    if jq -e '.build.ok and .tests.ok and .lint.ok and .security.ok' "$vout" >/dev/null 2>&1; then
      # Commit once we are green
      (cd "$wt" && git commit -m "agent($TASK_ID): apply plan (attempt $attempt)") || true
      # Keep a human-readable diff (with secrets redacted)
      (cd "$wt" && git diff HEAD~1..HEAD --patch) | redact_secrets > "$dir/patch.diff" 2>/dev/null || true
      say "✅ Green. Diff saved to $dir/patch.diff (secrets redacted)"
      break
    else
      if [ "$AUTO" -eq 1 ]; then
        say "⚠️  Not green; you can increase --loops or edit manually in: $wt"
      else
        say "ℹ️  Review failures, edit in: $wt  → re-run: dp agent run --id $TASK_ID"
      fi
    fi
    attempt=$((attempt+1))
  done
}

cmd_pr() {
  local TASK_ID="${1:-}"
  local TITLE="${2:-}"

  if [[ -z "$TASK_ID" ]]; then
    say "Usage: dp agent pr --id <task_id> [--title 'PR title']"
    exit 1
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --id) TASK_ID="${2:-}"; shift 2;;
      --title) TITLE="${2:-}"; shift 2;;
      *) shift;;
    esac
  done

  local dir="$ART/agent/$TASK_ID"
  [[ -d "$dir" ]] || { echo "error: task not found: $TASK_ID"; exit 2; }

  local wt="$ART/agent/$TASK_ID/work"
  [[ -d "$wt" ]] || { echo "error: no sandbox found for $TASK_ID"; exit 2; }

  # Default title from spec if not provided
  if [[ -z "$TITLE" ]]; then
    TITLE="agent($TASK_ID): $(head -n1 "$dir/spec.md" 2>/dev/null || echo "automated changes")"
  fi

  cd "$wt"
  # Include username in branch for multi-user environments
  local user_slug="${USER,,}"  # lowercase username
  user_slug="${user_slug//[^a-z0-9-]/-}"  # sanitize to alphanumeric and dashes
  local branch="agent/${user_slug}/${TASK_ID}"
  say "▸ Pushing branch: $branch"
  git push -u origin "$branch" || { echo "error: failed to push branch"; exit 1; }

  # Create PR using gh if available
  if command -v gh >/dev/null 2>&1; then
    # Get risk tags from the verification
    local risk_tags=""
    if [[ -f "$dir/verify.json" ]]; then
      # Check for high-risk changes
      local risks=()
      grep -q '"auth"' "$dir/spec.md" 2>/dev/null && risks+=("auth")
      grep -q '"database\|sql\|migration"' "$dir/spec.md" 2>/dev/null && risks+=("db")
      grep -q '"docker\|kubernetes\|terraform"' "$dir/spec.md" 2>/dev/null && risks+=("infra")
      grep -q '"model\|ml\|ai"' "$dir/spec.md" 2>/dev/null && risks+=("ml")
      grep -q '"security\|encrypt\|secret"' "$dir/spec.md" 2>/dev/null && risks+=("security")

      # Join risks with commas
      risk_tags=$(IFS=,; echo "${risks[*]}")
    fi

    # Build label arguments
    local label_args="--label agentic --label owner:${USER}"
    if [[ -n "$risk_tags" ]]; then
      IFS=',' read -ra RISKS <<< "$risk_tags"
      for risk in "${RISKS[@]}"; do
        label_args="$label_args --label risk:${risk}"
      done
    fi

    # Create PR with labels
    gh pr create --title "$TITLE" \
      --body "Generated by dp agent for task $TASK_ID

Task: $(head -n1 "$dir/spec.md" 2>/dev/null || echo "N/A")
Owner: ${USER}
Branch: $branch" \
      $label_args || {
      say "Created branch but failed to create PR. Create manually."
    }
  else
    say "Branch pushed. Create PR manually:"
    say "  Branch: $branch"
  fi

  say "✅ Branch pushed: $branch"
}

cmd_verify() {
  # Standalone verification command
  ensure_sys
  local TASK_ID=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --id) TASK_ID="${2:-}"; shift 2;;
      *) TASK_ID="$1"; shift;;
    esac
  done

  # Get latest task if not specified
  if [[ -z "$TASK_ID" ]]; then
    # shellcheck disable=SC2010
    TASK_ID=$(ls -t "$ART/agent" 2>/dev/null | grep '^task-' | head -1)
    [[ -z "$TASK_ID" ]] && { echo "No task ID specified and no tasks found"; exit 2; }
  fi

  local dir="$ART/agent/$TASK_ID"
  [[ ! -d "$dir" ]] && { echo "Task $TASK_ID not found"; exit 2; }

  # Find worktree
  local wt="$dir/worktree"
  if [[ ! -d "$wt" ]]; then
    wt="$HOME/.devpilot/worktrees/$TASK_ID"
    [[ ! -d "$wt" ]] && { echo "Worktree not found for task $TASK_ID"; exit 2; }
  fi

  # Run verification and output result
  verify_repo "$wt" "$TASK_ID" "$dir/verify.json"
  cat "$dir/verify.json"

  # Summary
  if jq -e '.build.ok and .tests.ok and .lint.ok and .security.ok' "$dir/verify.json" >/dev/null 2>&1; then
    say "✅ All checks passed"
  else
    say "⚠️  Some checks failed - see verify.json for details"
  fi
}

cmd_eval() {
  shift
  # Simple local evaluation: read a suite YAML with a list of goals
  local suite="${1:-.agent/suites/local/sample.yaml}"
  [ -f "$suite" ] || { echo "usage: dp agent eval <suite.yaml>"; exit 2; }
  have yq || { echo "error: yq required to parse $suite"; exit 2; }
  local base; base=$(yq -r '.base // "main"' "$suite")
  local ts_id
  ts_id="eval-$(date +%Y%m%d%H%M%S)"
  local rep="$ART/agent/$ts_id"; mkdir -p "$rep"
  echo "{\"suite\":\"$suite\",\"base\":\"$base\",\"started\":\"$(now)\"}" > "$rep/report.json"
  local pass=0 fail=0 total=0
  while IFS= read -r goal; do
    total=$((total+1))
    IFS='|' read -r TASK_ID BASE <<<"$(id_new "$base")"
    "$0" new --goal "$goal" --base "$base" >/dev/null
    "$0" run --id "$TASK_ID" --auto --loops 1 >/dev/null
    if jq -e '.build.ok and .tests.ok and .lint.ok and .security.ok' "$ART/agent/$TASK_ID/verify.json" >/dev/null 2>&1; then
      pass=$((pass+1))
    else
      fail=$((fail+1))
    fi
  done < <(yq -r '.goals[]' "$suite")
  echo "{\"suite\":\"$suite\",\"total\":$total,\"pass\":$pass,\"fail\":$fail}" > "$rep/summary.json"
  echo "✅ Eval summary → $rep/summary.json   ($pass/$total pass)"
}

usage() {
  cat <<'HELP'
dp agent — minimal agentic coding (P1)
  dp agent new --goal "<text>" [--base main]       # create task + SPEC
  dp agent run --id <task_id> [--auto] [--loops N] # PLAN + apply codemods → VERIFY
  dp agent verify --id <task_id>                   # run verification only
  dp agent pr  --id <task_id> [--title ...]        # push branch + open PR
  dp agent eval .agent/suites/local/sample.yaml    # run a local eval suite

Artifacts: artifacts/agent/<task_id>/{run.json,spec.md,plan.json,verify.json,work/}

Features:
  - Codemod-first edits with comby support
  - Targeted test execution for changed files
  - Coverage tracking with delta reporting
  - Context packing for better prompts
  - Local evaluation suites
  - Risk tagging support
HELP
}

# Main routing
case "${1:-}" in
  new)  shift; cmd_new "$@";;
  run)  shift; cmd_run "$@";;
  verify) shift; cmd_verify "$@";;
  pr)   shift; cmd_pr "$@";;
  eval) cmd_eval "$@";;
  -h|--help|"")
    usage
    ;;
  *)
    say "Unknown command: $1"
    usage
    exit 1
    ;;
esac
