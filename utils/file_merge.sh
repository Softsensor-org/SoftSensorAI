#!/usr/bin/env bash
# File merge utility - handles conflicts when setting up DevPilot in existing repos
set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Helpers
info() { printf "${CYAN}ℹ ${NC}%s\n" "$*"; }
warn() { printf "${YELLOW}⚠ ${NC}%s\n" "$*"; }
error() { printf "${RED}✗ ${NC}%s\n" "$*"; }
success() { printf "${GREEN}✓ ${NC}%s\n" "$*"; }

# Merge strategies
STRATEGY_SKIP="skip"          # Skip if file exists
STRATEGY_OVERWRITE="overwrite" # Overwrite existing file
STRATEGY_BACKUP="backup"       # Backup existing, then overwrite
STRATEGY_MERGE="merge"         # Merge new content with existing
STRATEGY_DIFF="diff"           # Show diff and prompt user
STRATEGY_APPEND="append"       # Append new content to existing

# Default strategy per file type
declare -A FILE_STRATEGIES=(
  ["CLAUDE.md"]="$STRATEGY_MERGE"
  ["CODEX.md"]="$STRATEGY_MERGE"
  [".env"]="$STRATEGY_SKIP"
  [".env.example"]="$STRATEGY_BACKUP"
  ["README.md"]="$STRATEGY_DIFF"
  ["CONTRIBUTING.md"]="$STRATEGY_MERGE"
  [".gitignore"]="$STRATEGY_MERGE"
  ["package.json"]="$STRATEGY_DIFF"
  ["requirements.txt"]="$STRATEGY_MERGE"
  ["justfile"]="$STRATEGY_MERGE"
  ["Makefile"]="$STRATEGY_MERGE"
  [".pre-commit-config.yaml"]="$STRATEGY_MERGE"
)

# Check if file has DevPilot markers
has_devpilot_markers() {
  local file="$1"
  grep -q "DevPilot\|DEVPILOT\|Generated by DevPilot\|devpilot:" "$file" 2>/dev/null
}

# Create backup
create_backup() {
  local file="$1"
  local backup="${file}.backup.$(date +%Y%m%d_%H%M%S)"
  cp "$file" "$backup"
  info "Created backup: $backup"
  echo "$backup"
}

# Merge CLAUDE.md files
merge_claude_md() {
  local existing="$1"
  local new="$2"
  local output="$3"

  # Create temporary file for merged content
  local merged=$(mktemp)

  # Extract sections from existing file
  local existing_sections=$(mktemp)
  awk '/^#/ {print $0}' "$existing" > "$existing_sections"

  # Start with header
  echo "# AI Assistant Configuration" > "$merged"
  echo "" >> "$merged"

  # Add merge notice
  echo "<!-- DevPilot Merged: $(date +%Y-%m-%d) -->" >> "$merged"
  echo "" >> "$merged"

  # If existing has custom instructions, preserve them
  if grep -q "^## Custom Instructions" "$existing"; then
    echo "## Custom Instructions" >> "$merged"
    echo "" >> "$merged"
    awk '/^## Custom Instructions/,/^##[^#]/' "$existing" | sed '1d;$d' >> "$merged"
    echo "" >> "$merged"
  fi

  # Add DevPilot standard sections from new file
  echo "## DevPilot Configuration" >> "$merged"
  echo "" >> "$merged"

  # Copy main content from new file, skipping header
  tail -n +3 "$new" >> "$merged"

  # If existing has project-specific sections not in new, append them
  echo "" >> "$merged"
  echo "## Project-Specific Configuration" >> "$merged"
  echo "" >> "$merged"

  # Extract non-standard sections from existing
  while IFS= read -r section; do
    if ! grep -q "$section" "$new"; then
      echo "$section" >> "$merged"
      awk "/$section/,/^##[^#]/" "$existing" | sed '$d' >> "$merged"
      echo "" >> "$merged"
    fi
  done < "$existing_sections"

  # Copy to output
  cp "$merged" "$output"

  # Cleanup
  rm -f "$merged" "$existing_sections"
}

# Merge .gitignore files
merge_gitignore() {
  local existing="$1"
  local new="$2"
  local output="$3"

  # Create temporary file
  local merged=$(mktemp)

  # Copy existing file
  cp "$existing" "$merged"

  # Add DevPilot section marker if not present
  if ! grep -q "# DevPilot" "$merged"; then
    echo "" >> "$merged"
    echo "# DevPilot additions" >> "$merged"
  fi

  # Add new entries that don't exist
  while IFS= read -r line; do
    # Skip empty lines and comments
    [[ -z "$line" || "$line" =~ ^# ]] && continue

    # Check if pattern already exists
    if ! grep -q "^${line}$" "$merged"; then
      echo "$line" >> "$merged"
    fi
  done < "$new"

  # Copy to output
  cp "$merged" "$output"
  rm -f "$merged"
}

# Merge package.json dependencies
merge_package_json() {
  local existing="$1"
  local new="$2"
  local output="$3"

  # Requires jq for JSON manipulation
  if ! command -v jq &> /dev/null; then
    warn "jq not installed, cannot merge package.json intelligently"
    return 1
  fi

  # Merge scripts
  local merged_scripts=$(jq -s '.[0].scripts * .[1].scripts' "$existing" "$new")

  # Merge devDependencies
  local merged_devdeps=$(jq -s '.[0].devDependencies * .[1].devDependencies' "$existing" "$new")

  # Create merged file
  jq --argjson scripts "$merged_scripts" \
     --argjson devdeps "$merged_devdeps" \
     '.scripts = $scripts | .devDependencies = $devdeps' "$existing" > "$output"
}

# Show diff and prompt user
show_diff_prompt() {
  local existing="$1"
  local new="$2"
  local filename=$(basename "$existing")

  echo ""
  warn "File exists: $filename"
  echo ""

  # Show diff if available
  if command -v diff &> /dev/null; then
    echo "${BOLD}Differences:${NC}"
    diff -u "$existing" "$new" | head -50 || true
    echo ""
  fi

  echo "${BOLD}Options:${NC}"
  echo "  [s] Skip - Keep existing file"
  echo "  [o] Overwrite - Replace with new file"
  echo "  [b] Backup & overwrite - Save existing, use new"
  echo "  [m] Merge - Attempt to merge both files"
  echo "  [v] View - View both files side by side"
  echo ""

  read -p "Choose action [s/o/b/m/v]: " -n 1 -r
  echo ""

  case "$REPLY" in
    o|O) echo "$STRATEGY_OVERWRITE" ;;
    b|B) echo "$STRATEGY_BACKUP" ;;
    m|M) echo "$STRATEGY_MERGE" ;;
    v|V)
      echo "=== Existing file ==="
      head -20 "$existing"
      echo "=== New file ==="
      head -20 "$new"
      show_diff_prompt "$existing" "$new"
      ;;
    *) echo "$STRATEGY_SKIP" ;;
  esac
}

# Main merge function
merge_file() {
  local source_file="$1"
  local target_file="$2"
  local strategy="${3:-auto}"

  local filename=$(basename "$target_file")

  # If target doesn't exist, just copy
  if [ ! -f "$target_file" ]; then
    cp "$source_file" "$target_file"
    success "Created $filename"
    return 0
  fi

  # Determine strategy
  if [ "$strategy" = "auto" ]; then
    # Use predefined strategy or default to diff
    strategy="${FILE_STRATEGIES[$filename]:-$STRATEGY_DIFF}"

    # If file has DevPilot markers, prefer merge
    if has_devpilot_markers "$target_file"; then
      strategy="$STRATEGY_MERGE"
    fi
  fi

  # Apply strategy
  case "$strategy" in
    "$STRATEGY_SKIP")
      info "Skipping existing $filename"
      ;;

    "$STRATEGY_OVERWRITE")
      cp "$source_file" "$target_file"
      success "Overwrote $filename"
      ;;

    "$STRATEGY_BACKUP")
      create_backup "$target_file"
      cp "$source_file" "$target_file"
      success "Backed up and overwrote $filename"
      ;;

    "$STRATEGY_MERGE")
      local temp_merged=$(mktemp)

      # Use specific merge function if available
      case "$filename" in
        "CLAUDE.md"|"CODEX.md")
          merge_claude_md "$target_file" "$source_file" "$temp_merged"
          ;;
        ".gitignore")
          merge_gitignore "$target_file" "$source_file" "$temp_merged"
          ;;
        "package.json")
          if merge_package_json "$target_file" "$source_file" "$temp_merged"; then
            :
          else
            warn "Failed to merge $filename, showing diff instead"
            strategy=$(show_diff_prompt "$target_file" "$source_file")
            merge_file "$source_file" "$target_file" "$strategy"
            return
          fi
          ;;
        *)
          # Generic merge: append with markers
          cp "$target_file" "$temp_merged"
          echo "" >> "$temp_merged"
          echo "# === DevPilot Additions Below ===" >> "$temp_merged"
          cat "$source_file" >> "$temp_merged"
          ;;
      esac

      mv "$temp_merged" "$target_file"
      success "Merged $filename"
      ;;

    "$STRATEGY_DIFF")
      strategy=$(show_diff_prompt "$target_file" "$source_file")
      merge_file "$source_file" "$target_file" "$strategy"
      ;;

    "$STRATEGY_APPEND")
      cat "$source_file" >> "$target_file"
      success "Appended to $filename"
      ;;

    *)
      error "Unknown strategy: $strategy"
      return 1
      ;;
  esac
}

# Main execution
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
  # Script is being executed directly
  if [ $# -lt 2 ]; then
    echo "Usage: $0 <source_file> <target_file> [strategy]"
    echo ""
    echo "Strategies:"
    echo "  skip      - Skip if file exists"
    echo "  overwrite - Overwrite existing file"
    echo "  backup    - Backup existing, then overwrite"
    echo "  merge     - Merge new content with existing"
    echo "  diff      - Show diff and prompt user"
    echo "  append    - Append new content to existing"
    echo "  auto      - Automatically choose based on file type (default)"
    exit 1
  fi

  merge_file "$1" "$2" "${3:-auto}"
fi
