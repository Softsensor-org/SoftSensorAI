#!/usr/bin/env bash
# Generate Command Registry from Justfile and scripts
# Creates a searchable command palette for DevPilot
set -euo pipefail

OUTPUT="${1:-commands.md}"
JSON_OUTPUT="${2:-commands.json}"
FIRST_JSON=true

# Extract description from file header comment
extract_description() {
  local file="$1"
  local name="$2"
  grep -m1 "^# " "$file" 2>/dev/null | sed 's/^# //' || echo "Run $name"
}

# Add JSON separator if needed
add_json_separator() {
  if [[ "$FIRST_JSON" == "false" ]]; then
    echo "," >> "$JSON_OUTPUT"
  fi
  FIRST_JSON=false
}

# Add command to both outputs
add_command() {
  local command="$1"
  local description="$2"
  local category="$3"
  local source="$4"

  # Markdown output
  echo "| \`$command\` | $description | $category | $source |" >> "$OUTPUT"

  # JSON output
  add_json_separator
  printf '  {"command":"%s","description":"%s","category":"%s","source":"%s"}' \
    "$command" "$description" "$category" "$source" >> "$JSON_OUTPUT"
}

# Process shell scripts in a directory
process_directory() {
  local dir="$1"
  local category="$2"
  local header="$3"

  if [[ ! -d "$dir" ]]; then
    return 0
  fi

  echo "" >> "$OUTPUT"
  echo "## $header" >> "$OUTPUT"
  echo "" >> "$OUTPUT"

  for script in "$dir"/*.sh; do
    [[ -f "$script" ]] || continue
    local basename="${script##*/}"
    local name="${basename%.sh}"
    local desc=$(extract_description "$script" "$name")
    add_command "./$dir/$basename" "$desc" "$category" "$dir"
  done
}

# Parse Justfile targets
parse_justfile() {
  local justfile
  if [[ -f "Justfile" ]] || [[ -f "justfile" ]]; then
    justfile=$(ls Just* just* 2>/dev/null | head -1 || true)
  else
    return 0
  fi

  # Extract recipes with descriptions
  awk '
    /^[a-z][a-z0-9_-]*:/ {
      recipe = $1
      sub(/:.*/, "", recipe)

      if (prev_line ~ /^# /) {
        desc = prev_line
        sub(/^# /, "", desc)
        printf "%s|%s\n", recipe, desc
      } else {
        printf "%s|Run %s\n", recipe, recipe
      }
    }
    { prev_line = $0 }
  ' "$justfile" | while IFS='|' read -r recipe desc; do
    add_command "just $recipe" "$desc" "build" "Justfile"
  done
}

# Parse dp commands
parse_dp_commands() {
  if [[ ! -f "bin/dp" ]]; then
    return 0
  fi

  echo "" >> "$OUTPUT"

  local -a dp_commands=(
    "init:Initialize project with doctor, profile, and system build:setup"
    "tickets:Generate structured backlog (JSON/CSV):planning"
    "review:AI review of local diff:review"
    "review --preview:AI review with preview logs:review"
    "project:Create/show project profile:config"
    "palette:Open command palette:meta"
  )

  for cmd_spec in "${dp_commands[@]}"; do
    IFS=: read -r cmd desc cat <<< "$cmd_spec"
    add_command "dp $cmd" "$desc" "$cat" "dp"
  done
}

# Initialize output files
cat > "$OUTPUT" <<'EOF'
# DevPilot Command Registry

Quick reference for all available commands. Use `dp palette` or `just palette` to search interactively.

## Commands

| Command | Description | Category | Source |
|---------|-------------|----------|--------|
EOF

echo '{"commands": [' > "$JSON_OUTPUT"

# Generate registry
parse_justfile
parse_dp_commands
process_directory "scripts" "script" "Scripts"
process_directory "tools" "tool" "Tools"

# Finalize outputs
echo "" >> "$JSON_OUTPUT"
echo "]}" >> "$JSON_OUTPUT"

# Add footer to markdown
cat >> "$OUTPUT" <<'EOF'

## Categories

- **build**: Build, test, and development commands
- **setup**: Project initialization and configuration
- **planning**: Ticket generation and project planning
- **review**: Code review and analysis
- **config**: Configuration management
- **script**: Utility scripts
- **tool**: Development tools
- **meta**: Meta commands and navigation

## Quick Access

```bash
# Interactive command palette
dp palette

# Or use just
just palette

# Search for specific commands
dp palette test
dp palette review
```

---
*Generated by generate_command_registry.sh*
EOF

echo "âœ… Generated $OUTPUT and $JSON_OUTPUT"
